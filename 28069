#include "DSP28x_Project.h"     // Device Headerfile and Examples Include File


void kimhyeonsooPWM(void);
void kimhyeonsooGPIO(void);

__interrupt void ADC_interrupt_service_routine(void);
__interrupt void externalSwitchSSS(void);
__interrupt void externalSwitchDIR(void);

#define sample_period_PWM 0.000025

/* Global Variables used in this example: */
int16 PWMPeriod;
int16 initial_CMPA_1 = 2200;
int16 initial_CMPA_2 = 50;

//OCR1A=(c<<1)+c+(c>>3);        //2+1+(1/8)=3.125
//OCR1A=c+(c>>1)+(c>>4);        //1+(1/2)+(1/16)=1.5625
//OCR1A=(c>>1)+(c>>2)+(c>>5);   //(1/2)+(1/4)+(1/32)=0.78125
//OCR1A=(c>>2)+(c>>3)+(c>>6);   //(1/4)+(1/8)+(1/64)=0.390625

//////////// switching frequency selection ////////////
#define k_5             3.1250              // the ratio of ICR1 to c(ADCW) for 5kHz
#define k_10            1.5625              // the ratio of ICR1 to c(ADCW) for 10kHz
#define k_20            0.78125             // the ratio of ICR1 to c(ADCW) for 20kHz
#define k_40            0.390625            // the ratio of ICR1 to c(ADCW) for 40kHz
#define MaxCnt_5        3199
#define MaxCnt_10       1599
#define MaxCnt_20       799
#define MaxCnt_40       399
#define SpeedMaxCnt     62499
#define PPR             1024

#define startStopGo     0x0000
#define startStopNo     0x0008
#define directionCW     0x0010
#define directionCCW    0x0000


//#define rotationCW      (1<<GpioDataRegs.GPACLEAR.bit.GPIO3)|(1<<GpioDataRegs.GPASET.bit.GPIO4)
//#define rotationCCW     (1<<GpioDataRegs.GPACLEAR.bit.GPIO3)|(1<<GpioDataRegs.GPACLEAR.bit.GPIO4)
//#define rotationStop    (1<<GpioDataRegs.GPASET.bit.GPIO3)
#define rotationCW      (startStopGo        +\
                         directionCW)
#define rotationCCW     (startStopGo        +\
                         directionCCW)
#define rotationStop    startStopNo


volatile unsigned int adcValue12                    =0;
volatile unsigned int adcValue10                    =0;
volatile unsigned int directionCnt                  =0;
volatile unsigned int motorCnt                      =0;
volatile unsigned int hallData                      =0;
volatile unsigned int hallTrigger                   =0;
volatile unsigned int encTrigger                    =0;
volatile unsigned int speedClock                    =0;
volatile unsigned int pulse                         =0;
volatile unsigned int LoopCount;

unsigned int startStopButton                        =0;
unsigned int startStopSwitch                        =0;
unsigned int directionButton                        =0;

float speedRPM                                      =0;
float Tclock                                        =0;
volatile unsigned int valueCheck;


///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

__interrupt void ADC_interrupt_service_routine(void) // __interrupt void VS. interrupt ???
{
    /*
    GPIO3:start/stop port
    GPIO4:DIR port
    GPIO5:start/stop button
    GPIO6:DIR button
    */

    if(motorCnt)
    {
        adcValue12=(float32)(0xffff&AdcResult.ADCRESULT0);
        valueCheck=(adcValue12>>1)+(adcValue12>>5)+(adcValue12>>6)+(adcValue12>>9)+(adcValue12>>11); //means 0.54931640625
//        EPwm1Regs.CMPA.half.CMPA=(float)adcValue12*0.54931640625;
        EPwm1Regs.CMPA.half.CMPA=(float)valueCheck;

        if(directionCnt)
        {
            GpioDataRegs.GPACLEAR.bit.GPIO3=1;
            GpioDataRegs.GPACLEAR.bit.GPIO4=1;
//            GpioDataRegs.GPASET.all=rotationCCW;
            //rotationCCW
        }
        else
        {
            GpioDataRegs.GPACLEAR.bit.GPIO3=1;
            GpioDataRegs.GPASET.bit.GPIO4=1;
//            GpioDataRegs.GPASET.all=rotationCW;
            //rotationCW;
        }
    }
    else
    {
        EPwm1Regs.CMPA.half.CMPA=0;             // motor stop
        GpioDataRegs.GPASET.bit.GPIO3=1;        // rotationStop
//        GpioDataRegs.GPASET.all=rotationStop;
    }

    AdcRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;       // Clear ADCINT1 flag reinitialize for next SOC
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;     // Acknowledge interrupt to PIE
    return;
}

__interrupt void externalSwitchSSS(void){
    DELAY_US(20000);                                //chattering prevention
    if((GpioDataRegs.GPADAT.all&0x0020)==0){       //start/stop select button
        motorCnt^=1;
    }

    // Acknowledge this interrupt to get more from group 1
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

__interrupt void externalSwitchDIR(void){
    DELAY_US(20000);                                //chattering prevention
    if((GpioDataRegs.GPADAT.all&0x0040)==0){       // direction select button
        if(GpioDataRegs.GPADAT.bit.GPIO3==1){
            directionCnt^=1;
        }
    }

    // Acknowledge this interrupt to get more from group 1
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

void main(void)
{

   InitSysCtrl();
   InitEPwm1Gpio();             // 여기서 포트 확인해
   kimhyeonsooGPIO();
   DINT;
   InitPieCtrl();
   IER = 0x0000;
   IFR = 0x0000;
   InitPieVectTable();

   //////////////////////////////////////
   //////////////////////////////////////
   EALLOW;
   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;
   EDIS;

   kimhyeonsooPWM();

   EALLOW;
   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;
   EDIS;
   //////////////////////////////////////
   //////////////////////////////////////

   EALLOW;
   PieVectTable.ADCINT1= &ADC_interrupt_service_routine;
   PieVectTable.XINT1= &externalSwitchSSS;                 // StartStopSelection(kim added)
   PieVectTable.XINT2= &externalSwitchDIR;                 // DIRECTION(kim added)
   EDIS;
   InitAdc();                           // powerSupply-related register settings, in F2806x_Adc.c

   // Enable ADCINT1 in PIE
   PieCtrlRegs.PIECTRL.bit.ENPIE = 1;   // Enable the PIE block(kim added)
   PieCtrlRegs.PIEIER1.bit.INTx1 = 1;   // Enable INT 1.1 in the PIE
   PieCtrlRegs.PIEIER1.bit.INTx4 = 1;   // External interrupt enable(kim added)(for start/stop switch)
   PieCtrlRegs.PIEIER1.bit.INTx5 = 1;   // External interrupt enable(kim added)(for direction switch)

   IER |= M_INT1;                       // Enable CPU Interrupt 1
   IER |= M_INT2;                       // for extInterrupt(kim added)
   IER |= M_INT3;                       // for extInterrupt(kim added)
   EINT;                                // Enable Global interrupt INTM
   ERTM;                                // Enable Global realTime interrupt DBGM


   //* ADC settings *//
   EALLOW;

   AdcRegs.ADCCTL2.bit.ADCNONOVERLAP = 1;    // Enable non-overlap mode
   AdcRegs.ADCCTL1.bit.INTPULSEPOS   = 1;    // ADCINT1 trips after AdcResults latch
   AdcRegs.ADCCTL1.bit.ADCREFSEL     = 1;
   AdcRegs.INTSEL1N2.bit.INT1E       = 1;    // Enabled ADCINT1
   AdcRegs.INTSEL1N2.bit.INT1CONT    = 0;    // Disable ADCINT1 Continuous mode
   AdcRegs.INTSEL1N2.bit.INT1SEL     = 0;    // setup EOC0 to trigger ADCINT1 to fire
   AdcRegs.ADCSOC0CTL.bit.CHSEL      = 2;    // set SOC0 channel select to ADCINA2(load voltage)
//   AdcRegs.ADCSOC1CTL.bit.CHSEL      = 4;    // set SOC1 channel select to ADCINA4(inductor current)
   AdcRegs.ADCSOC0CTL.bit.TRIGSEL    = 5;    // set SOC0 start trigger on EPWM1A, due to round-robin SOC0 converts first then SOC1
//   AdcRegs.ADCSOC1CTL.bit.TRIGSEL    = 5;    // set SOC1 start trigger on EPWM1A, due to round-robin SOC0 converts first then SOC1
   AdcRegs.ADCSOC0CTL.bit.ACQPS      = 6;    // set SOC0 S/H Window to 7 ADC Clock Cycles, (6 ACQPS plus 1)
//   AdcRegs.ADCSOC1CTL.bit.ACQPS      = 6;    // set SOC1 S/H Window to 7 ADC Clock Cycles, (6 ACQPS plus 1)
   EDIS;



   // Assumes ePWM1 clock is already enabled in InitSysCtrl();
   EPwm1Regs.ETSEL.bit.SOCAEN   = 1;        // Enable SOC on A group
   EPwm1Regs.ETSEL.bit.SOCASEL  = 2;        // Select SOC from CMPA on upcount
   EPwm1Regs.ETPS.bit.SOCAPRD   = 1;        // Generate pulse on 1st event



   //* External Interrupt settings *//
   // GPIO0 is XINT1, GPIO1 is XINT2
   EALLOW;
   GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = 5;   // XINT1 is GPIO5(start/stop switch)(kim added)
   GpioIntRegs.GPIOXINT2SEL.bit.GPIOSEL = 6;   // XINT2 is GPIO6(direction switch)(kim added)
   EDIS;

   // Configure XINT1 and XINT2
   XIntruptRegs.XINT1CR.bit.POLARITY = 3;      // Falling/Rising edge interrupt(kim added)
   XIntruptRegs.XINT2CR.bit.POLARITY = 3;      // Falling/Rising edge interrupt(kim added)

   // Enable XINT1 and XINT2
   XIntruptRegs.XINT1CR.bit.ENABLE = 1;        // Enable XINT1
   XIntruptRegs.XINT2CR.bit.ENABLE = 1;        // Enable XINT2
}

void kimhyeonsooGPIO(void)
{
    //output-set(clear),mux,dir
    //input-mux,dir,qsel,pud
    EALLOW;
    GpioDataRegs.GPACLEAR.bit.GPIO3     = 1;
    GpioDataRegs.GPACLEAR.bit.GPIO4     = 1;

    GpioCtrlRegs.GPAMUX1.bit.GPIO3      = 0;    // GPIO3 = GPIO3
    GpioCtrlRegs.GPAMUX1.bit.GPIO4      = 0;    // GPIO4 = GPIO4
    GpioCtrlRegs.GPAMUX1.bit.GPIO5      = 0;    // GPIO5 = GPIO5
    GpioCtrlRegs.GPAMUX1.bit.GPIO6      = 0;    // GPIO6 = GPIO6

    GpioCtrlRegs.GPADIR.bit.GPIO3       = 1;    // GPIO3 output(PORTA0(startStop))
    GpioCtrlRegs.GPADIR.bit.GPIO4       = 1;    // GPIO4 output(PORTA1(DIR))
//    GpioCtrlRegs.GPADIR.bit.GPIO5       = 0;    // GPIO5 input(switch(start/stop control))
//    GpioCtrlRegs.GPADIR.bit.GPIO6       = 0;    // GPIO6 input(switch(direction control))

//    GpioCtrlRegs.GPAQSEL1.bit.GPIO3     = 0;
//    GpioCtrlRegs.GPAQSEL1.bit.GPIO4     = 0;
    GpioCtrlRegs.GPAQSEL1.bit.GPIO5     = 4;
    GpioCtrlRegs.GPAQSEL1.bit.GPIO6     = 4;

//    GpioCtrlRegs.GPAPUD.bit.GPIO3       = 0;
//    GpioCtrlRegs.GPAPUD.bit.GPIO4       = 0;
    GpioCtrlRegs.GPAPUD.bit.GPIO5       = 0;
    GpioCtrlRegs.GPAPUD.bit.GPIO6       = 0;

    EDIS;
}

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

void kimhyeonsooPWM(void)
{
    PWMPeriod = sample_period_PWM * 90000000;      //2250,20kHz

   // Setup TBCLK
   EPwm1Regs.TBPRD = PWMPeriod;                   // Set timer period 801 TBCLKs
   EPwm1Regs.TBPHS.half.TBPHS = 0x0000;           // Phase is 0
   EPwm1Regs.TBCTR = 0x0000;                      // Clear counter

   // Set Compare values
//   EPwm1Regs.CMPA.half.CMPA = initial_CMPA_1;     // Set compare A value    // 인터럽트 서비스 루틴에서 듀티 생성
//   EPwm1Regs.CMPB = 8000;               // Set Compare B value    // 인터럽트 서비스 루틴에서 듀티 생성

   // Setup counter mode
   EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Count up-down
   EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
   EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
   EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1;

   // Setup shadowing
   EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
   EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
   EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;  // Load on Zero
   EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

   // Set actions
   EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;             // Set PWM1A on event A, up count
   EPwm1Regs.AQCTLA.bit.CAD = AQ_SET;           // Clear PWM1A on event A, down count

//   EPwm1Regs.AQCTLB.bit.CBU = AQ_SET;             // Set PWM1B on event B, up count
//   EPwm1Regs.AQCTLB.bit.CBD = AQ_CLEAR;           // Clear PWM1B on event B, down count
}
